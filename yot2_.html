<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>折り紙</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
          "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/controls/OrbitControls.js",
          "three/addons/geometries/TextGeometry.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/geometries/TextGeometry.js",
          "three/addons/loaders/FontLoader.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/FontLoader.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const container = document.querySelector(".container");
      const canvasEl = document.querySelector("#canvas");

      // パラメータを入力 -------------------------------------------------------------------

      let origami = {
        params: {
          width: 36,
          height: 36,
        },
        els: {
          origami: new THREE.Group(),
          fixGroup: new THREE.Group(),
          moveGroup: new THREE.Group(),
          board1: new THREE.Mesh(),
          board2: new THREE.Mesh(),
          board3: new THREE.Mesh(),
        },
        animated: {
          foldingAngle: 0, // 折りたたむ角度、単位はラジアン
        },
      };

      const tan = Math.tan(Math.PI / 8);
      const basicWidthAndHeight = origami.params.width;

      const board1 = [
        [basicWidthAndHeight * (tan - 1), 0, 0],
        [basicWidthAndHeight * tan, basicWidthAndHeight, 0],
        [basicWidthAndHeight * tan, 0, 0],
      ];

      const board2 = [
        [basicWidthAndHeight * (tan - 1), 0, 0],
        [0, 0, 0],
        [basicWidthAndHeight * tan, basicWidthAndHeight, 0],
      ];

      const board3 = [
        [0, 0, 0],
        [basicWidthAndHeight * tan, 0, 0],
        [basicWidthAndHeight * tan, basicWidthAndHeight, 0],
      ];

      const boards = {
        fixBoards: [board1, board2],
        moveBoards: [board3],
      };

      // 回転軸を設定
      // board3の1番目の頂点から0番目の頂点へのベクトルを回転軸とする
      const rotateAxis = new THREE.Vector3(
        board3[2][0] - board3[0][0],
        board3[2][1] - board3[0][1],
        board3[2][2] - board3[0][2]
      ).normalize();

      // -------------------------------------------------------------------

      let renderer, scene, camera, orbit;

      initScene();
      window.addEventListener("resize", updateSceneSize);

      function initScene() {
        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
          canvas: canvasEl,
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          40,
          container.clientWidth / container.clientHeight,
          10,
          1000
        );
        camera.position.set(0, 0, 2).multiplyScalar(70);

        updateSceneSize();
        addAxesAndOrbitControls();

        scene.add(origami.els.origami);
        setGeometryForBoards();

        createBoardElements();

        render();
      }

      function addAxesAndOrbitControls() {
        // x, y, z軸を表示
        const axesHelper = new THREE.AxesHelper(1000);
        scene.add(axesHelper);

        // OrbitControlsの設定
        orbit = new OrbitControls(camera, canvasEl);
        orbit.enableZoom = false;
        orbit.enableDamping = true;
        orbit.autoRotate = false;
        orbit.autoRotateSpeed = 0.25;
      }

      function render() {
        orbit.update();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      // ウィンドウサイズが変更されたときに呼び出される
      function updateSceneSize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      // それぞれの板を動く板と固定板のグループに追加
      function setGeometryForBoards() {
        boards.fixBoards.forEach((board, index) => {
          origami.els.fixGroup.add(origami.els[`board${index + 1}`]);
        });
        boards.moveBoards.forEach((board, index) => {
          origami.els.moveGroup.add(
            origami.els[`board${boards.fixBoards.length + index + 1}`]
          );
        });
        origami.els.origami.add(origami.els.fixGroup, origami.els.moveGroup);
      }

      // 板のジオメトリを設定
      function createBoardElements() {
        boards.fixBoards.forEach((board, index) => {
          const vertices = new Float32Array(board.flat());
          origami.els[`board${index + 1}`].geometry =
            new THREE.BufferGeometry();
          origami.els[`board${index + 1}`].geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(vertices, 3)
          );
        });

        boards.moveBoards.forEach((board, index) => {
          const vertices = new Float32Array(board.flat());
          origami.els[`board${boards.fixBoards.length + index + 1}`].geometry =
            new THREE.BufferGeometry();
          origami.els[
            `board${boards.fixBoards.length + index + 1}`
          ].geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(vertices, 3)
          );
        });

        // const board1Vertices = new Float32Array(board1.flat());
        // const board2Vertices = new Float32Array(board2.flat());
        // const board3Vertices = new Float32Array(board3.flat());

        // origami.els.board1.geometry = new THREE.BufferGeometry();
        // origami.els.board1.geometry.setAttribute(
        //   "position",
        //   new THREE.BufferAttribute(board1Vertices, 3)
        // );

        // origami.els.board2.geometry = new THREE.BufferGeometry();
        // origami.els.board2.geometry.setAttribute(
        //   "position",
        //   new THREE.BufferAttribute(board2Vertices, 3)
        // );

        // origami.els.board3.geometry = new THREE.BufferGeometry();
        // origami.els.board3.geometry.setAttribute(
        //   "position",
        //   new THREE.BufferAttribute(board3Vertices, 3)
        // );

        const frontMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color(0xff0000),
          wireframe: false,
          side: THREE.FrontSide,
        });
        // 片方wireframeにする,
        // 重なった時に色が重なる時がある、折り目がわかったほうがいいため
        const backMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color(0xa9a9a9),
          wireframe: true,
          side: THREE.BackSide,
        });

        boards.fixBoards.forEach((board, index) => {
          const frontMesh = new THREE.Mesh(
            origami.els[`board${index + 1}`].geometry,
            frontMaterial
          );
          const backMesh = new THREE.Mesh(
            origami.els[`board${index + 1}`].geometry,
            backMaterial
          );
          origami.els.fixGroup.add(frontMesh, backMesh);
        });

        boards.moveBoards.forEach((board, index) => {
          const frontMesh = new THREE.Mesh(
            origami.els[`board${boards.fixBoards.length + index + 1}`].geometry,
            frontMaterial
          );
          const backMesh = new THREE.Mesh(
            origami.els[`board${boards.fixBoards.length + index + 1}`].geometry,
            backMaterial
          );
          origami.els.moveGroup.add(frontMesh, backMesh);
        });

        // const frontMesh1 = new THREE.Mesh(
        //   origami.els.board1.geometry,
        //   frontMaterial
        // );
        // const backMesh1 = new THREE.Mesh(
        //   origami.els.board1.geometry,
        //   backMaterial
        // );

        // const frontMesh2 = new THREE.Mesh(
        //   origami.els.board2.geometry,
        //   backMaterial
        // );
        // const backMesh2 = new THREE.Mesh(
        //   origami.els.board2.geometry,
        //   frontMaterial
        // );

        // const frontMesh3 = new THREE.Mesh(
        //   origami.els.board3.geometry,
        //   frontMaterial
        // );

        // const backMesh3 = new THREE.Mesh(
        //   origami.els.board3.geometry,
        //   backMaterial
        // );

        // origami.els.fixGroup.add(frontMesh1, backMesh1);
        // origami.els.fixGroup.add(frontMesh2, backMesh2);
        // origami.els.moveGroup.add(frontMesh3, backMesh3);

        updateBoardsTransform();
      }

      // 折り率に応じて板を折りたたむ(回転する)
      function updateBoardsTransform() {
        const quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(rotateAxis, origami.animated.foldingAngle);
        origami.els.moveGroup.setRotationFromQuaternion(quaternion);
      }

      const rangebar = document.getElementById("rangebar");

      rangebar.addEventListener("input", (e) => {
        const value = e.target.value;
        origami.animated.foldingAngle = -value * (Math.PI / 180);
        console.log(origami.animated.foldingAngle);
        updateBoardsTransform();
      });
    </script>
  </head>
  <body>
    <div class="page">
      <div class="container">
        <canvas id="canvas"></canvas>
        <div class="ui-controls">
          0<input
            type="range"
            name="radius"
            aria-label="折りたたむ角度"
            min="0"
            max="180"
            value="0"
            id="rangebar"
          />180
        </div>
      </div>
    </div>
  </body>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
    .page {
      width: 100%;
      height: 100vh;
    }
    .container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
    }
    .container .ui-controls {
      position: absolute;
      top: 70%;
      left: 70%;
      user-select: none;
      font-family: sans-serif;
      text-align: end;
    }
  </style>
</html>
