<html>
  <head>
    <meta charset="utf-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
          "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/controls/OrbitControls.js",
          "three/addons/geometries/TextGeometry.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/geometries/TextGeometry.js",
          "three/addons/loaders/FontLoader.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/FontLoader.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const container = document.querySelector(".container");
      const canvasEl = document.querySelector("#canvas");

      let boards = {
        params: {
          width: 80,
          height: 45,
        },
        els: {
          group: new THREE.Group(),
          leftBoard: new THREE.Mesh(),
          leftBoard2: new THREE.Mesh(),
          rightBoard: new THREE.Mesh(),
          rightBoard2: new THREE.Mesh(),
        },
        animated: {
          foldingAngle: 0, // 折りたたむ角度、単位はラジアン
        },
      };

      let renderer, scene, camera, orbit;

      initScene();
      window.addEventListener("resize", updateSceneSize);

      function initScene() {
        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
          canvas: canvasEl,
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          45,
          container.clientWidth / container.clientHeight,
          10,
          1000
        );
        camera.position.set(0.5, 0, 1.3).multiplyScalar(70);

        updateSceneSize();
        addAxesAndOrbitControls();

        // 4枚の板を生成
        scene.add(boards.els.group);
        setGeometryForBoards();

        const materials = [
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0xff0000),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0x0000ff),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0x00ff00),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0xffff00),
            wireframe: true,
          }),
        ];
        boards.els.leftBoard.material = materials[0];
        boards.els.rightBoard.material = materials[1];
        // boards.els.leftBoard2.material = materials[2];
        // boards.els.rightBoard2.material = materials[3];
        createBoardElements();

        render();
      }

      function addAxesAndOrbitControls() {
        // 軸の設定
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(-1000, 0, 0),
          new THREE.Vector3(1000, 0, 0),
        ]);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // OrbitControlsの設定
        orbit = new OrbitControls(camera, canvasEl);
        orbit.enableZoom = false;
        orbit.enableDamping = true;
        orbit.autoRotate = false;
        orbit.autoRotateSpeed = 0.25;
      }

      function render() {
        orbit.update();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      // ウィンドウサイズが変更されたときに呼び出される
      function updateSceneSize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      // 2つの板をグループに追加
      function setGeometryForBoards() {
        boards.els.group.add(
          boards.els.leftBoard,
          boards.els.rightBoard,
          boards.els.leftBoard2,
          boards.els.rightBoard2
        );
      }

      // 板のジオメトリを設定
      function createBoardElements() {
        boards.els.leftBoard.geometry = new THREE.PlaneGeometry(
          boards.params.width / 2, // 左板の幅
          boards.params.height
        );
        boards.els.rightBoard.geometry = new THREE.PlaneGeometry(
          boards.params.width / 2, // 右板の幅
          boards.params.height
        );
        boards.els.leftBoard2.geometry = new THREE.PlaneGeometry(
          boards.params.width / 2, // 左板の幅
          boards.params.height
        );
        boards.els.rightBoard2.geometry = new THREE.PlaneGeometry(
          boards.params.width / 2, // 右板の幅
          boards.params.height
        );
        updateBoardsTransform();
      }

      // 折り率に応じて板を折りたたむ
      function updateBoardsTransform() {
        // 左の板を左側に配置し、折りたたむ
        boards.els.leftBoard.position.x = -boards.params.width / 4;
        boards.els.leftBoard.rotation.y = boards.animated.foldingAngle;

        boards.els.leftBoard2.position.x = -boards.params.width / 4;
        boards.els.leftBoard2.rotation.y = boards.animated.foldingAngle;

        // 右の板を右側に配置し、折りたたむ
        boards.els.rightBoard.position.x = boards.params.width / 4;
        boards.els.rightBoard.rotation.y = -boards.animated.foldingAngle;

        boards.els.rightBoard2.position.x = boards.params.width / 4;
        boards.els.rightBoard2.rotation.y = -boards.animated.foldingAngle;

        // 折り畳まれる時に折り目ができるように板を動かす
        // widthは板2枚の幅の合計なので、4で割る
        const cos = Math.cos(boards.animated.foldingAngle);
        boards.els.leftBoard.position.x = (boards.params.width / 4) * cos;
        boards.els.rightBoard.position.x = (boards.params.width / 4) * cos;

        boards.els.leftBoard2.position.x = (boards.params.width / 4) * cos;
        boards.els.rightBoard2.position.x = (boards.params.width / 4) * cos;

        const sin = Math.sin(boards.animated.foldingAngle);
        boards.els.leftBoard.position.z = (-boards.params.width / 4) * sin;
        boards.els.rightBoard.position.z = (boards.params.width / 4) * sin;

        boards.els.leftBoard2.position.z = (-boards.params.width / 4) * sin;
        boards.els.rightBoard2.position.z = (boards.params.width / 4) * sin;
      }

      const rangebar = document.getElementById("rangebar");

      rangebar.addEventListener("input", (e) => {
        const value = e.target.value;
        boards.animated.foldingAngle = value * (Math.PI / 180);
        console.log(boards.animated.foldingAngle);
        updateBoardsTransform();
      });
    </script>
  </head>
  <body>
    <div class="page">
      <div class="container">
        <canvas id="canvas"></canvas>
        <div class="ui-controls">
          0<input
            type="range"
            name="radius"
            min="0"
            max="90"
            value="0"
            id="rangebar"
          />90
        </div>
        <div class="ui-controls2">
          0<input
            type="range"
            name="radius"
            min="0"
            max="90"
            value="0"
            id="rangebar2"
          />90
        </div>
      </div>
    </div>
  </body>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
    .page {
      width: 100%;
      height: 100vh;
    }
    .container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
    }
    .container .ui-controls {
      position: absolute;
      top: 70%;
      left: 70%;
      user-select: none;
      font-family: sans-serif;
      text-align: end;
    }

    .container .ui-controls2 {
      position: absolute;
      top: 75%;
      left: 70%;
      user-select: none;
      font-family: sans-serif;
      text-align: end;
    }
  </style>
</html>
