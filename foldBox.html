<html>
  <head>
    <meta charset="utf-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
          "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/controls/OrbitControls.js",
          "three/addons/geometries/TextGeometry.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/geometries/TextGeometry.js",
          "three/addons/loaders/FontLoader.js": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/FontLoader.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";

      const container = document.querySelector(".container");
      const canvasEl = document.querySelector("#canvas");

      let box = {
        params: {
          width: 27,
          widthLimits: [15, 70],
          length: 80,
          lengthLimits: [70, 120],
          depth: 45,
          depthLimits: [15, 70],
        },
        els: {
          group: new THREE.Group(),
          backHalf: {
            width: new THREE.Mesh(),
            length: new THREE.Mesh(),
          },
          frontHalf: {
            width: new THREE.Mesh(),
            length: new THREE.Mesh(),
          },
        },
        animated: {
          openingAngle: 0.02 * Math.PI,
        },
      };

      let renderer, scene, camera, orbit;
      const axisTitles = [];
      const boxSize = [15, 30, 1];

      let params = { angle: 0 };

      initScene();
      window.addEventListener("resize", updateSceneSize);

      function initScene() {
        // rendererはどのように描画するかを決める
        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
          canvas: canvasEl,
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // sceneは3D空間を作成する
        scene = new THREE.Scene();
        // cameraはどのように見るかを決める
        camera = new THREE.PerspectiveCamera(
          45,
          container.clientWidth / container.clientHeight,
          10,
          1000
        );
        camera.position.set(0.5, 0, 1.3).multiplyScalar(70);

        updateSceneSize();
        addAxesAndOrbitControls();

        // boxを生成
        scene.add(box.els.group);
        setGeometryHierarchy();

        const materials = [
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0xff0000),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0xdc00c9),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0x008be4),
            wireframe: true,
          }),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(0x006100),
            wireframe: true,
          }),
        ];
        box.els.frontHalf.width.material = materials[0];
        box.els.frontHalf.length.material = materials[1];
        box.els.backHalf.width.material = materials[2];
        box.els.backHalf.length.material = materials[3];

        createBoxElements();

        render();
      }

      // 軸とOrbitControlsを追加
      // OrbitControlsはマウスでカメラを操作するためのもの
      function addAxesAndOrbitControls() {
        // X軸とY軸のタイトルを追加
        const loader = new FontLoader();
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        loader.load(
          "https://unpkg.com/three@0.138.0/examples/fonts/helvetiker_regular.typeface.json",
          (font) => {
            const textParams = {
              font: font,
              size: 1.5,
              height: 0.1,
              curveSegments: 2,
            };
            {
              const textGeometry = new TextGeometry("axis X", textParams);
              axisTitles[0] = new THREE.Mesh(textGeometry, textMaterial);
              axisTitles[0].position.set(30, 1, 0);
            }
            {
              const textGeometry = new TextGeometry("axis Y", textParams);
              axisTitles[1] = new THREE.Mesh(textGeometry, textMaterial);
              axisTitles[1].position.set(1, 30, 0);
            }
            scene.add(axisTitles[0], axisTitles[1]);
          }
        );

        // X軸とY軸の線を追加
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        {
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-1000, 0, 0),
            new THREE.Vector3(1000, 0, 0),
          ]);
          const line = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(line);
        }
        {
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -1000, 0),
            new THREE.Vector3(0, 1000, 0),
          ]);
          const line = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(line);
        }

        // OrbitControlsを追加
        orbit = new OrbitControls(camera, canvasEl);
        orbit.enableZoom = false;
        orbit.enableDamping = true;
        orbit.autoRotate = true;
        orbit.autoRotateSpeed = 0.25;
      }

      // boxのジオメトリを設定?
      function render() {
        orbit.update();
        axisTitles.forEach((t) => {
          t.quaternion.copy(camera.quaternion);
        });
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      // ウィンドウサイズが変更されたときに呼び出される
      function updateSceneSize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      function setGeometryHierarchy() {
        box.els.group.add(
          box.els.frontHalf.width,
          box.els.frontHalf.length,
          box.els.backHalf.width,
          box.els.backHalf.length
        );
      }

      function createBoxElements() {
        for (let halfIdx = 0; halfIdx < 2; halfIdx++) {
          for (let sideIdx = 0; sideIdx < 2; sideIdx++) {
            const half = halfIdx ? "frontHalf" : "backHalf";
            const side = sideIdx ? "width" : "length";

            const sideWidth =
              side === "width" ? box.params.width : box.params.length;
            box.els[half][side].geometry = new THREE.PlaneGeometry(
              sideWidth,
              box.params.depth
            );
          }
        }
        updatePanelsTransform();
      }

      function updatePanelsTransform() {
        // place width-sides aside of length-sides (not animated)
        box.els.frontHalf.width.position.x = 0.5 * box.params.length;
        box.els.backHalf.width.position.x = -0.5 * box.params.length;

        // rotate width-sides from 0 to 90 deg
        box.els.frontHalf.width.rotation.y = box.animated.openingAngle;
        box.els.backHalf.width.rotation.y = box.animated.openingAngle;

        // move length-sides to keep the box centered
        const cos = Math.cos(box.animated.openingAngle); // animates from 1 to 0
        box.els.frontHalf.length.position.x = -0.5 * cos * box.params.width;
        box.els.backHalf.length.position.x = 0.5 * cos * box.params.width;

        // move length-sides to define box inner space
        const sin = Math.sin(box.animated.openingAngle); // animates from 0 to 1
        box.els.frontHalf.length.position.z = 0.5 * sin * box.params.width;
        box.els.backHalf.length.position.z = -0.5 * sin * box.params.width;
      }

      const rangebar = document.getElementById("rangebar");

      rangebar.addEventListener("input", (e) => {
        const value = e.target.value;
        box.animated.openingAngle = value * (Math.PI / 180);
        updatePanelsTransform();
      });
    </script>
  </head>
  <body>
    <div class="page">
      <div class="container">
        <canvas id="canvas"></canvas>
        <div class="ui-controls">
          0<input
            type="range"
            name="radius"
            min="0"
            max="90"
            value="0"
            id="rangebar"
          />90
        </div>
      </div>
    </div>
  </body>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
    .page {
      width: 100%;
      height: 200vh;
    }
    .container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
    }
    .container .ui-controls {
      position: absolute;
      top: 70%;
      left: 70%;
      user-select: none;
      font-family: sans-serif;
      text-align: end;
    }
  </style>
</html>
